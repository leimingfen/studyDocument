# Node.js - Day2

## 写给在座的各位同学
**保持动力，善于思考，乐于实践**！
年轻健康是件幸福的事情、学习是件快乐的事情，而你拥有全部！

## 复习
1. 能够概述什么是NodeJS
2. 能掌握 path 环境变量的配置并概述 path 环境变量的作用
3. 能写出一个响应 hello world 的服务
4. 能写出一个类似于 Apache 服务器的服务
5. 能进行基本的文件读写

## 同步和异步的对比【非阻塞I/O和阻塞I/O】
### 异步读取文件


### 异步嵌套读取文件


### 同步读取文件


### 异步和同步操作中，捕获错误的方式


## Node 中的模块化
![模块化房屋](images/模块化房屋.jpg)
![笔记本主板](images/笔记本主板.jpg)


### 什么是程序开发中的模块及好处
+ 什么是程序开发中的模块化：把一些功能类似的代码，封装到一个单独的文件中去，这些单独抽离出来的代码文件，就能够提供各种各样好用的功能；这种通过代码功能分割文件的方式，叫做程序中的模块化；
+ 好处：保证了每个文件的功能（职能）单一；需要什么特定的功能，直接调用某一个特定的模块；对将来程序开发和维护都有好处！


### Node 中如何实现模块化
在Node中通过三个东西实现模块化：
+ module：表示一个模块，在Node中，最常见的模块，就是一个个的JS文件！
+ require：作用是加载其他模块用的；在一个JS文件中，如何引用其他JS文件中的成员呢？就是用require
+ exports：在Node的模块中，如果这个模块需要向外暴露一些成员，供其他JS模块使用，那么，需要使用exports向外暴露这些成员！

> Node 中的模块化，主要解决的JS文件之间的相互依赖关系！

### Node 中的模块的分类
node由三部分组成：ECMAScript + 核心API + 第三方等API
#### 核心模块
+ 什么是核心模块：官方，发现一些功能模块使用非常频繁，然后，官方把这些模块，编译成了二进制可执行文件，然后打包到了Node的安装包中；所以，这些核心模块就已经随着安装Node时候，被安装到了本地；
+ 如何使用核心模块
　使用require（‘核心模块的名称’）；


#### 第三方模块
+ 什么是第三方模块：出了官方提供的好用的核心模块之外，我们程序员发现，还有一些使用也很频繁的代码和方法，一些牛逼的团体、个人、公司，开发出了好用的模块，通过NPM官网，托管出去，供其他人下载使用的这些模块；统称为第三方模块；
+ 如何使用第三方模块
　－　通过moment这个第三方模块，来介绍如何使用一个第三方模块；
+ 第三方模块的使用方式：
 1. 先使用npm下载这个模块！【注意：在安装第三方模块的时候，安装的名字，就是你在require时候导入的名字】
 2. 使用require导入这个第三方模块！
 3. 通过官方文档，试着去使用这个第三方模块！
 4. 注意：无论是核心模块、还是第三方模块，都是通过 `标识符名称`来引用这个模块的！


#### 用户模块
+ 什么是用户模块：程序员自己定义的JS文件，统统数据用户模块！
+ 用户模块向外导出成员的两种方式：
 - 第一种方式：使用global对象，相当于浏览器中的window对象
		+ 1. 全局变量污染，
		+ 2. 不知道成员是从哪个模块中暴露 出去的
 - 推荐Node提供的exports


### exports 和 module.exports 的区别
1. 通过 module.exports 可以使用 . 的形式追加属性，也可以使用 等号 直接赋值的形式导出成员；

2. exports 只能通过 . 的形式追加属性；不能使用 等号 直接赋值的形式！

3. 注意： 在一个 module 中，最终向外暴露的成员，以 module.exports 指向的对象为准！

4. 在一个模块中，不要混合使用 `module.exports` 和 `exports`


### 模块加载规则
1. 优先从缓存中加载
2. 加载核心模块:优先从缓存中加载；如果缓存中没有的话，再去执行加载核心模块！
3. 自己的模块:优先从缓存中加载；如果缓存中没有的话，再去执行加载用户模块！
 + 用户模块的查找规则：
 ```
用户模块的查找规则：
如果不写后缀名，则先严格按照给定的文件名去查找模块并加载执行；
index   ->  index.js  ->   index.json    ->  index.node
 ```
4. 第三方模块查找规则：
    1. node首先，查看项目根目录中有没有 `node_modules` 文件夹
    2. 查找 `node_modules` 文件夹中，有没有和第三方模块名称一致的文件夹
    3. 在模块对应的文件夹中，查找有没有 `package.json` 这个文件
    4. 在 `package.json` 文件中，查找有没有 `main` 属性
    5. 如果有 `main` 属性，并且 `main` 属性指向的路径存在，那么就尝试加载这个路径指定的文件！
    6. 如果 `package.json` 文件中，没有 `main` 属性，或者 `main` 属性指向的路径不存在，或者没有`package.json` 文件， 那么，Node尝试加载 模块根目录中 `index` 相关文件：`index.js` -> `index.json` -> `index.node`
    7. 如果在`node_modules`文件夹中，找不到对应的模块文件夹，或者在项目根目录中根本没有`node_modules`文件夹，则向上一层文件夹中去查找，查找规则同上！
    8. 如果上一层目录中也没有查找到，则再向上翻一层去查找，直到找到当前项目所在的盘符根目录为止！
    9. 如果找到了盘符根目录还找不到，则报错：`cannot find module ***`

## 只安装部署依赖项不安装开发工具
```
npm i --production
```

## 模块化
1. node中的模块化基于`commonJS`:最显著的特点所有依赖项都是同步加载的！！！
2. `commonJS`由于是一个同步加载规范，所以不适合浏览器端使用；于是，浏览器端需要使用异步的模块加载机制

## 结合art-template模板引擎在服务器端渲染页面
[art-template官方文档](https://aui.github.io/art-template/docs/)

## 服务端渲染和客户端渲染的对比
[博客园官网](https://www.cnblogs.com/)
1. 服务器端渲染
 + 特点：Node服务器先读取模板页面，再获取要渲染的数据，然后直接在服务器端把完整的页面渲染拼接好，然后通过网络一次性的把结果发送给浏览器去显示！【注意：通过服务器端渲染，在网络中传输的是一个真正页面】
 + 优点：请求次数少，速度快，对SEO友好
 + 缺点：服务器渲染压力大【在后端可以通过缓存机制去解决】
2. 客户端渲染
 + 特点：先访问服务器获取到模板页面，然后再通过Ajax获取要渲染的数据，拿到这两者之后，再客户端调用模板引擎，渲染得到模板字符串，然后通过JS的方式，把结果展示到页面上！【真正的页面是在客户端浏览器中怼出来的，在进行网络传输的时候，第一次传输的是模板页面，第二次传输的是数据】
 + 优点：减轻了服务器端的渲染压力
 + 缺点：请求次数多，用户体验可能没有服务器端渲染好（白屏效果）；对SEO不友好


## 使用`nodemon`来自动重启Node服务
1. 运行`npm i nodemon -g`全局安装模块
2. 使用方式 和 `node` 完全一样：
 + `node 要执行文件的路径`
 + `nodemon 要执行文件的路径`

## 文件列表小案例

## 获取文件的属性

## 在优化前, 先封装一个`根据指定路径读取文件内容`的方法【重点】

## 将读取文件夹的方法抽离出来，同时对error进行处理【重点】

## 相关文章
1. [art-template 官方文档](https://aui.github.io/art-template/)
2. [ES6 - 模板字符串](http://www.infoq.com/cn/articles/es6-in-depth-template-string)
3. [js中的数组对象排序](http://www.cnblogs.com/xljzlw/p/3694861.html)
4. [i5ting/tocmd.npm 将MD转换为HTML](https://github.com/i5ting/tocmd.npm)