  /*

​    \*   面向对象的思想

​    \*       思想：

​    \*           万物皆对象 -- 只要是任何存在的物体，都可以看出对象，这些对象都有特征和行为

​    \*           用属性描述特征，用方法描述行为

​    \*       代码：

​    \*           对象就是键值对的集合

​    *

​    \*       面向对象的过程：

​    \*           1 封装对象  ==> 使用构造函数和原型封装对象

​    \*           2 找对象

​    \*           3 指挥对象做事情

​    *

​    *

​    \*   创建对象

​    \*       1 new Object() / {}

​    \*       2 工厂模式

​    \*       3 自定义构造函数

​    *

​    \*   自定义构造函数存在问题：

​    \*       如果构造函数中有给对象设置方法，会浪费内存

​    *

​    \*   怎么解决：

​    \*       1 抽离出对象外面，使用一个全局函数代替每次的匿名函数

​    \*           风险： 可能会被覆盖

​    \*       2 使用原型的方式的方式解决

​    *

​    \*           构造函数.prototype.方法名 = fun()

​    *

​    \*   开始研究原型

​    \*       什么是原型

​    \*           就是构造函数的一个属性，指向另一个对象

​    *

​    \*       构造函数

​    \*           都有prototype属性，指向原型对象

​    \*       原型对象

​    \*           都有constructor属性指向构造函数

​    \*           也有__proto__,原型对象也是另一个构造函数的实例对象

​    \*       实例对象

​    \*           都有__proto__属性，指向原型对象

​    *

​    \*       多个原型对象形参一条链式关系 --- 原型链

​    *

​    \*       原型链的作用： 实现代码的共享(代码的重复使用)

​    \*           原型链上面的成员的访问规则：

​    \*               1 先用自己的

​    \*               2 自己没有，就找原型要

​    \*               3 原型也没有就找原型链

​    \*               4 原型链上也没有就返回undefined

​    *

​    \*       使用原型链实现继承

​    \*           1 借用构造函数继承

​    \*               构造函数.call(this,依次是调用构造函数需要的参数)

​    \*           2 使用原型实现继承

​    \*               构造函数.prototype = new 另一个构造函数();

​    *

​    *

​    \*  补充：

​    \*       更简单的原型

​    \*       拷贝继承