​    /*

​    \*  闭包

​    \*       一个函数，可以访问另一个函数的局部变量

​    \*       把局部变量保护起来，在特定的时候提供一个操作的接口，让其他人对这个数据进行操作

​    \*       步骤：

​    \*           1 外层函数

​    \*           2 局部变量

​    \*           3 内层函数

​    \*           4 内层函数操作外层函数的局部变量

​    \*           5 内层函数作为外层函数的返回值

​    *

​    \*        坏处：

​    \*           占用内存 -- 直到浏览器关闭

​    *

​    \*  沙箱

​    *

​    \*       沙箱 = 沙盘 + 箱子

​    *

​    \*       就是一个自调用函数，可以把里面的代码保护起来，这里面的代码就是我们封装好的函数，通过把这些函数作为window的属性存在，开放给沙箱之外的逻辑使用

​    *

​    \*       注意点：

​    \*           1 内部要使用的全是局部变量(思想,可移植性,执行效率)

​    \*           2 开口子供外部调用封装好的代码

​    *

​    \*           语法：

​    \*           (function(形参){

​    \*               封装代码

​    \*               开口子

​    \*           })(实参);

​    *

​    \*       作用：保护代码

​    *

​    \*  递归

​    \*       结局一些实际的问题：

​    \*           斐波那契数列+阶乘+      遍历DOm树+深拷贝+菜单树

​    *

​    \*  学习对象的成员的方法  --  查文档

​    *

​    \* */

//    var baba = {

//        name : '李大胆',

//        age : 48

//    }

//

//    var obj = {

//        name : '李狗蛋',

//        age : 18,

//        baba : baba

//    }

//

//    var o = {};

//    for(var key in obj){

//        if(typeof obj[key] == 'object'){

////            继续也是深拷贝

//            // 把对象的所有键值对复制过来

//            o[key] = {};

//            var objdebab = obj[key]

//            for(var k in objdebab){

//                obj[key][k] = objdebab[k];

//            }

//        }else{

//            o[key] = obj[key];

//        }

//

//    }

//    o.baba.name = '隔壁老王';

//    console.log(o);

//    console.log(obj);